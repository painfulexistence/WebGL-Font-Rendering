import { useState, useRef, useMemo, useEffect } from 'react'
import { Canvas } from '@react-three/fiber'
import { OrthographicCamera, Stats } from '@react-three/drei'
import * as THREE from 'three'
import TinySDF from '@mapbox/tiny-sdf'
import { SDFGlyphMaterial } from './materials/SDFGlyph'

const generateGlyphAtlas = (text, fontSize, fontFamily) => {
  const now = performance.now()
  const sdf = new TinySDF({
    fontSize: 96,
    fontFamily: fontFamily,
    fontWeight: 'normal',
    buffer: 5,
    radius: 5,
    cutoff: 0.25
  })
  const glyph = sdf.draw(text)
  const pixelCount = glyph.width * glyph.height

  // Note that the data generated by TinySDF is one byte per pixel
  // Standard material requires RGBA texutre, which means four bytes per pixel, so we need to create a (width * height * 4) bytes array
  let data = new Uint8Array(pixelCount * 4)
  for (let i = 0; i < pixelCount; i++) {
    data[4 * i] = data[4 * i + 1] = data[4 * i + 2] = data[4 * i + 3] = glyph.data[i]
  }

  // Create a texture from the array of bytes
  let tex = new THREE.DataTexture(data, glyph.width, glyph.height, THREE.RGBAFormat, THREE.UnsignedByteType)
  tex.flipY = true
  tex.minFilter = THREE.LinearMipMapLinearFilter
  tex.magFilter = THREE.LinearFilter
  tex.generateMipmaps = true
  tex.needsUpdate = true
  
  console.log(performance.now() - now)
  return tex
}

const defaultFontSize = 32
const defaultFontFamily = 'Arial'

function App() {
  const camera = useRef()
  const [text, setText] = useState('人無一物以報天')
  const [fontSize, setFontSize] = useState(defaultFontSize)
  const [fontFamily, setFontFamily] = useState(defaultFontFamily)
  const [zoomLevel, setZoomLevel] = useState(1)
  const [pointer, setPointer] = useState({ isDown: false, x: NaN, y: NaN })
  const texture = useMemo(() => generateGlyphAtlas(text, fontSize, fontFamily), [text, fontFamily])
  const [textVertices, textUVs] = useMemo(() => {
    let vertices = []
    let UVs = []
    var alignmentX = -text.length / 2.0
    var alignmentY = -0.5
    for (let i = 0; i < text.length; i++) {
      vertices.push((1.0 + alignmentX + i) * fontSize, (1.0 + alignmentY) * fontSize, +0.0)
      vertices.push((0.0 + alignmentX + i) * fontSize, (1.0 + alignmentY) * fontSize, +0.0)
      vertices.push((0.0 + alignmentX + i) * fontSize, (0.0 + alignmentY) * fontSize, +0.0)

      vertices.push((0.0 + alignmentX + i) * fontSize, (0.0 + alignmentY) * fontSize, +0.0)
      vertices.push((1.0 + alignmentX + i) * fontSize, (0.0 + alignmentY) * fontSize, +0.0)
      vertices.push((1.0 + alignmentX + i) * fontSize, (1.0 + alignmentY) * fontSize, +0.0)

      UVs.push(1.0, 1.0)
      UVs.push(0.0, 1.0)
      UVs.push(0.0, 0.0)

      UVs.push(0.0, 0.0)
      UVs.push(1.0, 0.0)
      UVs.push(1.0, 1.0)
    }
    return [
      new Float32Array(vertices), 
      new Float32Array(UVs)
    ]
  }, [text, fontSize])

  const handleWheel = (e) => {
    setZoomLevel((prev) => (prev + e.deltaY / 100.0))
  }

  const handlePointerDown = (e) => {
    setPointer({...pointer, isDown: true})
  }

  const handlePointerMove = (e) => {
    if (pointer.isDown && pointer.x && pointer.y) {
      const movementX = e.clientX - pointer.x
      const movementY = e.clientY - pointer.y
      const pos = camera.current.position
      camera.current.position.set(pos.x - movementX / zoomLevel, pos.y + movementY / zoomLevel, pos.z)
    }
    setPointer({...pointer, x: e.clientX, y: e.clientY})
  }

  const handlePointerUp = (e) => {
    if (pointer.isDown) { 
      setPointer({isDown: false, x: NaN, y: NaN})
    }
  }

  return (
    <>
      <Stats showPanel={0} />
      <Canvas 
        dpr={window.devicePixelRatio}
        onWheel={handleWheel}
        onPointerDown={handlePointerDown}
        onPointerMove={handlePointerMove}
        onPointerUp={handlePointerUp}
        onPointerOut={handlePointerUp}
        onPointerLeave={handlePointerUp}
        style={{cursor: pointer.isDown ? 'grab' : 'auto'}}
      >
        <OrthographicCamera
          ref={camera}
          makeDefault
          zoom={Math.max(0, zoomLevel)}
          top={100}
          bottom={-100}
          left={-100}
          right={100}
          near={1}
          far={100}
          position={[0, 0, 10]}
          rotation={[0, 0, 0]}
        />
        <color attach='background' args={['#030303']} />
        <mesh>
          <planeGeometry args={[fontSize, fontSize]} />
          {/*
          <bufferGeometry ref={textGeometry} attach='geometry'>
            <bufferAttribute attach='attributes-position' array={textVertices} count={textVertices.length / 3} itemSize={3} />
            <bufferAttribute attach='attributes-uv' array={textUVs} count={textUVs.length / 2} itemSize={2} />
          </bufferGeometry>
          */}
          <shaderMaterial 
            transparent
            side={THREE.FrontSide} 
            args={[{...SDFGlyphMaterial, uniforms: { buffer: { value: 0.75 }, alphaThreshold: { value: 0. }, uTexture: { value: texture } }}]} 
          />
        </mesh>
      </Canvas>
      <div id="overlay-ui">
        <label>
          Font Family
          <br />
          <select value={fontFamily} onChange={(e) => setFontFamily(e.target.value)}>
            {
              ['Arial', 'Verdana', 'Times New Roman', 'Georgia', 'Monaco', 'Courier New', 'Papyrus'].map((font) => (
                <option key={font} value={font} defaultValue={font === defaultFontSize}>{font}</option>
              ))
            }
          </select>
        </label>
        <label>
          Font Size 
          <br />
          <input type='range' value={fontSize} min={1} max={256} step={1} onChange={(e) => setFontSize(e.target.value)} />
        </label>
        <label>
          Text Input
          <br />
          <input type='text' value={text} onChange={(e) => setText(e.target.value)} />
        </label>
      </div>
    </>
  )
}

export default App
